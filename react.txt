
* react-redux
 - context, provider传递store
 - connet高阶组件中通过usecontext获取store，将state，dispatch作为属性传递给组件，
   并且通过useEffect设置订阅（就是redux中的订阅），当有状态变化时，forceUpdate更新组件
   
   import React, {
      useContext,
      useEffect,
      useReducer,
      useState,
      useCallback,
      useLayoutEffect
    } from "react";

    // 通过Context传递store
    // *step1 创建一个Context对象
    const Context = React.createContext();
    // *step2 通过Provider组件传递value（store）
    export function Provider({store, children}) {
      return <Context.Provider value={store}>{children}</Context.Provider>;
    }

    // *step3 子组件接收 context value (Consumser\contextType\useContext)
    // 方法1 connect
    // hoc 函数，参数是组件，返回值是个新组件
    export const connect = (
      mapStateToProps = state => state,
      mapDispatchToProps
    ) => WrappedComponent => props => {
      const store = useContext(Context);
      const {getState, dispatch, subscribe} = store;
      // store state
      const stateProps = mapStateToProps(getState());

      let dispatchProps = {dispatch};

      if (typeof mapDispatchToProps === "object") {
        dispatchProps = bindActionCreators(mapDispatchToProps, dispatch);
      } else if (typeof mapDispatchToProps === "function") {
        dispatchProps = mapDispatchToProps(dispatch);
      }
      // 让函数强制更新的方法
      // const [, forceUpdate] = useReducer(x => x + 1, 0);
      // const [, forceUpdate] = useState({});

      const forceUpdate = useForceUpdate();
      // * useEffect _ _  DOM变更  effect执行(订阅)
      // * useLayoutEffect __   DOM变更-effect执行(订阅)

      // 订阅
      //

      useLayoutEffect(() => {
        //有订阅 一定要有取消订阅
        const unsubscribe = store.subscribe(() => {
          // todo 让函数组件更新
          forceUpdate();
        });

        return () => {
          if (unsubscribe) {
            unsubscribe();
          }
        };
      }, [store]);

      return <WrappedComponent {...props} {...stateProps} {...dispatchProps} />;
    };

    // hook只能用在函数组件或者是自定义hook
    function useForceUpdate() {
      const [state, setState] = useState(0);
      const update = useCallback(() => {
        setState(prev => prev + 1);
      }, []);

      return update;
    }

    function bindActionCreator(creator, dispatch) {
      return (...args) => dispatch(creator(...args));
    }

    export function bindActionCreators(creators, dispatch) {
      let obj = {};

      // todo
      for (let key in creators) {
        obj[key] = bindActionCreator(creators[key], dispatch);
      }

      return obj;
    }

    // 方法2 hooks
    export function useSelector(selector) {
      const store = useStore();
      const {getState} = store;

      const selectState = selector(getState());

      const forceUpdate = useForceUpdate();
      // * useEffect _ _  DOM变更  effect执行(订阅)
      // * useLayoutEffect __   DOM变更-effect执行(订阅)

      // 订阅
      //

      useLayoutEffect(() => {
        //有订阅 一定要有取消订阅
        const unsubscribe = store.subscribe(() => {
          // todo 让函数组件更新
          forceUpdate();
        });

        return () => {
          if (unsubscribe) {
            unsubscribe();
          }
        };
      }, [store]);

      return selectState;
    }

    function useStore() {
      const store = useContext(Context);
      return store;
    }

    export function useDispatch() {
      const store = useStore();
      return store.dispatch;
    }

   
* redux
 - subscribe(fn) --> fn被存在一个数组中 --> 当dispatch执行时，遍历数组执行一个个的fn，vue中也是store.subscribe(fn)
 
* 事件的发布订阅模式
 - on(event, fn) --> event与函数被存入一个对象 --> emit(event, data)时 --> 遍历this.handles[event]
 class EventEmitter {
    constructor() {
        this.handler = {};
    }
    on(eventName, callback) {
        if (!this.handles) {
            this.handles = {};
        }
        if (!this.handles[eventName]) {
            this.handles[eventName] = [];
        }
        this.handles[eventName].push(callback);
    }
    emit(eventName, ...arg) {
        if (this.handles[eventName]) {
            for (var i = 0; i < this.handles[eventName].length; i++) {
                this.handles[eventName][i](...arg);
            }
        }

     }
 }

 const event = new EventEmitter(); 
 event.on('some_event', num =>  { 
     console.log('some_event 事件触发:'+num); 
 }); 
 let num = 0
 setInterval(() =>  { 
     event.emit('some_event' , num ++ ); 
 }, 1000); 
